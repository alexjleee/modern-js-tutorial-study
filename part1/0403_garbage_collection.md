# 가비지 컬렉션

- 자바스크립트 엔진은 자동으로 필요 없게 된 값을 찾아내 삭제하여 메모리를 관리한다.

- 메모리는 필요할 때 할당되며, 사용(read/write) 후 필요 없어지면 해제된다. 할당과 해제는 자바스크립트 같은 고수준 언어에서는 암묵적으로 작동한다. 현재의 자바스크립트에서 명시적으로 가비지 컬렉션을 작동시킬 수는 없다.

## 가비지 컬렉션 기준

- 도달 가능성(reacchability) : 값에 접근할 수 있는지 여부

- 자바스크립트 엔진 내의 가비지 컬렉터(garbage collector)는 계속해서 모든 객체를 모니터링하며 도달할 수 없는 객체는 삭제한다.

- 루트(root) : 명백한 이유 없이는 삭제되지 않는 도달 가능한 값

  - 현재 함수의 지역변수와 매개변수

  - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수

  - 전역변수

  - 기타 등등

- 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 모두 도달 가능하다.

- 하나의 객체에 도달할 수 있는 방법이 여러 개 일 때, 즉 그 객체에 대한 참조가 여러 개 일 때, 참조 하나를 삭제해도 다른 참조로 접근할 수 있다면 메모리에서 사라지지 않는다.

- 도달할 수 없는 섬 : 만약 객체들이 서로 연결되어 섬과 같은 구조를 이루었는데, 밖에서 이 섬에 도달할 방법이 없는 경우 섬 전체가 메모리에서 삭제된다.

- cf. 자바스크립트에서 함수는 외부 함수의 변수에 접근할 수 있다 (클로저). 클로저는 실행이 끝난 외부 함수의 렉시컬 환경을 메모리에 유지한다. 메모리 누수를 해결하려면 클로저가 필요 없어졌을 때, 클로저를 담고 있는 객체를 다른 값으로 초기화시켜주면 된다.

```javascript
function outerFunc() {
  return function () {
    // ...
  };
}
const innerFunc = outerFunc();
innerFunc();

// 클로져가 필요 없어졌을 때,
innerFunc = null;
```

## 예시

```javascript
let user = {
  name: 'Alex';
} // user에는 {name: 'Alex'}에 대한 참조 값이 저장된다

let admin = user; // admin으로 참조 복사

let user = null;
// user는 더 이상 {name: 'Alex'}를 참조하지 않는다
// 하지만 admin을 통해 {name: 'Alex'}에 접근할 수 있으므로 'Alex'는 메모리에서 삭제되지 않는다.

let admin = null;
// 이제 'Alex'라는 값에 접근할 수 있는 방법이 모두 사라졌다. 가비지 컬렉터는 이를 메모리에서 삭제한다.
```

## 내부 알고리즘

- 가비지 컬렉션의 핵심 개념은 *참조*이다.

- Mark-and-Sweep : 가비지 컬렉션 기본 알고리즘

  1. 루트(root)를 mark

  2. 루트가 참조하는 모든 객체를 mark

  3. mark된 모든 객체들이 참조하는 객체도 mark (방문한 객체는 재방문 하지 않음)

  4. 모든 도달 가능한 객체를 mark할 때까지 반복

  5. mark되지 않은 모든 객체를 메모리에서 삭제

- 자바스크립트 엔진의 가비지 컬렉션 최적화 기법

  - 세대별 수집(generational collection) : 객체를 새로운 객체(생성 이후 빠르게 역할 수행 후 쓸모 없어지는 객체)와 오래된 객체(일정 시간 이상 살아남은 객체)로 구분하여 새로운 객체를 공격적으로 메모리에서 제거

  - 점진적 수집(incremental collection) : 객체를 방문하고 mark하는데 상당 시간이 소모되므로 가비지 컬렉션을 여러 부분으로 분리하여 작업 수행, 긴 지연을 여러 개의 짧은 지연으로 분산

  - 유휴 시간 수집(idle-time collection) : CPU가 유휴 상태일 때에만 실행
